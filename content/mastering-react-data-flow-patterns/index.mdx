---
title: "Mastering React Data Flow Patterns"
publishedAt: "2025-07-18"
summary: "Essential patterns that make React component communication cleaner and scalable."
---

Sometimes I wonder if we're making React more complicated than it needs to be. Have you ever found yourself passing props through five levels of components just to get a simple value to where it belongs? It's like trying to pass a message through a long telephone chain, by the time it reaches the end, something's bound to get lost or twisted.

The truth is, React gives us several elegant patterns for handling data flow between components. Think of these patterns as different types of conversations: sometimes you need a direct one on one chat, other times you want a group discussion, and occasionally you need to broadcast a message to everyone in the room.

Let me walk you through five patterns that will transform how you think about component communication.

## Compound Components: The Family Approach

Imagine a family dinner where everyone knows their role without being told. The parent sets the table, but each family member naturally knows where to sit and what to do. That's exactly how compound components work.

```jsx
// Instead of this prop heavy approach
<Modal
  isOpen={true}
  title="Delete Item"
  content="Are you sure?"
  onConfirm={handleDelete}
  onCancel={handleCancel}
/>

// We can create this natural, composable API
<Modal isOpen={true}>
  <Modal.Header>Delete Item</Modal.Header>
  <Modal.Body>Are you sure you want to delete this item?</Modal.Body>
  <Modal.Footer>
    <Modal.Button variant="danger" onClick={handleDelete}>
      Delete
    </Modal.Button>
    <Modal.Button variant="secondary" onClick={handleCancel}>
      Cancel
    </Modal.Button>
  </Modal.Footer>
</Modal>
```

The beauty here is flexibility. Each child component can access the parent's state through React's context, creating a seamless communication channel within the component family.

{/* TODO: Talk about how shadcn/ui uses compound components */}

## Container and Presentational: Separation of Concerns

Have you ever noticed how the best restaurants have a clear division of labor? The kitchen handles the cooking, while the _front of house_ focuses on presentation and service. This separation makes everything run smoother.

Container components are your kitchen: they handle the business logic, data fetching, and state management. Presentational components are your _front of house_: they focus solely on how things look and feel.

```jsx
// Container Component (the kitchen)
const UserListContainer = () => {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUsers().then((data) => {
      setUsers(data);
      setLoading(false);
    });
  }, []);

  return <UserList users={users} loading={loading} />;
};

// Presentational Component (front of house)
const UserList = ({ users, loading }) => {
  if (loading) return <LoadingSpinner />;

  return (
    <ul>
      {users.map((user) => (
        <UserCard key={user.id} user={user} />
      ))}
    </ul>
  );
};
```

This pattern makes your components easier to test, reuse, and reason about. Your presentational components become pure functions of their props.

## Controlled vs Uncontrolled: Who's in Charge?

Think about the difference between a guided tour and exploring a city on your own. Both have their place, depending on what you're trying to achieve.

Controlled components are like guided tours, the parent component maintains complete control over the state and behavior:

```jsx
const ControlledInput = () => {
  const [value, setValue] = useState("");

  return (
    <input
      value={value}
      onChange={(e) => setValue(e.target.value)}
      placeholder="Type something..."
    />
  );
};
```

Uncontrolled components are like exploring on your own, they manage their own state internally:

```jsx
const UncontrolledInput = () => {
  const inputRef = useRef();

  const handleSubmit = () => {
    console.log(inputRef.current.value);
  };

  return (
    <div>
      <input ref={inputRef} placeholder="Type something..." />
      <button onClick={handleSubmit}>Get Value</button>
    </div>
  );
};
```

Use controlled components when you need to validate, transform, or synchronize the data. Choose uncontrolled when you want simple, lightweight interactions.

## Render Props: The Swiss Army Knife

{/* TODO: Refer to the previous post */}

What if I told you there's a pattern that's like having a Swiss Army knife for component logic? Render props let you share stateful logic between components while keeping the rendering flexible.

```jsx
const DataFetcher = ({ url, children }) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((response) => response.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err);
        setLoading(false);
      });
  }, [url]);

  return children({ data, loading, error });
};

// Usage: same logic, different presentations
const UserProfile = () => (
  <DataFetcher url="/api/user">
    {({ data, loading, error }) => {
      if (loading) return <Skeleton />;
      if (error) return <ErrorMessage error={error} />;
      return <UserCard user={data} />;
    }}
  </DataFetcher>
);
```

The render prop pattern transforms your components into reusable logic containers that can adapt to any presentation need.

## Higher Order Components: The Decorator Pattern

Higher Order Components (HOCs) are like decorators in the real world. Just as you might add features to a basic phone case like wireless charging, a kickstand, extra storage, HOCs add capabilities to your components.

```jsx
const withLoading = (WrappedComponent) => {
  return function WithLoadingComponent(props) {
    if (props.loading) {
      return <LoadingSpinner />;
    }
    return <WrappedComponent {...props} />;
  };
};

const withError = (WrappedComponent) => {
  return function WithErrorComponent(props) {
    if (props.error) {
      return <ErrorMessage error={props.error} />;
    }
    return <WrappedComponent {...props} />;
  };
};

// Compose multiple HOCs
const UserList = withError(withLoading(BaseUserList));
```

HOCs let you compose behavior like building blocks, creating powerful combinations from simple pieces.

## Custom Hooks: The Modern Approach

While HOCs and render props are powerful, custom hooks have become the preferred way to share stateful logic in modern React. They're cleaner, more composable, and easier to test.

```jsx
const useApi = (url) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
};

// Clean, simple usage
const UserProfile = () => {
  const { data: user, loading, error } = useApi("/api/user");

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  return <UserCard user={user} />;
};
```

## Choosing the Right Pattern

Each pattern serves a specific purpose, like tools in a well organized workshop. Compound components excel at building flexible, composable APIs. Container/presentational separation keeps your code organized and testable. Controlled components give you precise control, while uncontrolled ones offer simplicity. Render props and HOCs provide powerful logic sharing, and custom hooks offer the cleanest modern approach.

The key is understanding when to use each tool. Start with the simplest approach that solves your problem, then evolve as your needs become more complex.

Remember, the goal isn't to use every pattern in every project. It's about having the right tool ready when you need it, creating React applications that are both powerful and maintainable.

Your components should tell a story, and these patterns help you write that story clearly and elegantly.
